#!/usr/bin/python3

import argparse
import errno
import json
import os
import re
import socket
import sqlite3
import sys
import itertools
from collections.abc import Mapping, Iterable
try:
    from json.decoder import JSONDecodeError
except ImportError:
    JSONDecodeError = ValueError  # for Python2

try:
    from configparser import ConfigParser
except ImportError:
    # for Python2 (we do not want to make dependency on the six library)
    from ConfigParser import SafeConfigParser as ConfigParser

from pprint import pprint as pp

"""
============= DISCLAIMER ==================
The code is not stabilized yet! Read: it's under heavy development!
You should expect that output format, CLI, and classes/functions in the script
can be significantly changed without notification.
===========================================

The current code is written as library and tool in one file, as it's expected
it will be copied oftenly; so for now, just one file to make copying simple.
Installation is not needed. Just copy the script wherever you want and use it.

First part of this script contains all stuff related to the library (generic
classes and function). In the second part you could find already implementation
of subcommands for the tool.

It's expected that people implement additional extensions / subcommands which
serve well for them.
"""


class LeappDatabaseEmpty(Exception):
    pass


class LogLevels():
    ERROR = 0
    WARNING = 1
    INFO = 2
    DEBUG = 3


class ActorSelector:
    ANY = "any"
    EXECUTED = "executed"
    PRODUCER = "producer"


def print_row(row):
    """
    Pretty print of a row obtained from DB

    It's supposed more for debugging & experimenting purposes
    """
    print(row)
    for i in row.keys():
        print("    {}: {}".format(i, row[i]))


def print_rows(rows):
    """
    Print every row in pretty format (see print_row)
    """
    for row in rows:
        print_row(row)


class Database(object):
    """
    Class to get various data about SQLite db in convenient way.
    """

    def __init__(self, db_file, debug=False):
        if not db_file:
            raise ValueError('Missing path to the db file.')
        if not os.path.exists(db_file):
            raise EnvironmentError(
                "The {} file doesn't exist. Specify the correct path to the"
                " leapp database file.".format(db_file)
            )

        self._db_file = db_file
        self._debug = debug
        self._con = sqlite3.connect(db_file)
        self._con.row_factory = sqlite3.Row
        self._last_execution_cursor = None

    def execute(self, cmd):
        """
        Execute the cmd command and return cursor.
        """
        if self._debug:
            # To be compatible with Py2 - it's expected the script could be
            # used on RHEL 7 system
            sys.stderr.write("SQL execution: {}\n".format(cmd))
        cursor = self._con.cursor()
        cursor.execute(cmd)
        self._last_execution_cursor = cursor
        return cursor

    def get_last_execution_column_names(self):
        """
        Return names of columns of the last SQL cmd or empty list.
        """
        if self._last_execution_cursor and self._last_execution_cursor.description:
            return [i[0] for i in self._last_execution_cursor.description]
        return []

    def get_tables(self):
        """
        Get list of tables.
        """
        cursor = self.execute("SELECT name FROM sqlite_master WHERE type='table'")
        return [row["name"] for row in cursor.fetchall()]

    def get_table_info(self, table):
        """
        Get information about a table.

        Just in case it's needed, so no need to open the db using sqlite3
        to be able to get info using `.schema` cmd.
        """
        cursor = self.execute(
            "SELECT * from sqlite_master WHERE type='table' AND name='{}'"
            .format(table))
        return cursor.fetchall()


class LeappDatabase(Database):
    """
    That's handler to get data from db.

    The class provides methods to obtain various data from db for another
    processing. If not specified, the obtained data are related just to the
    last execution (context) of leapp.
    """

    def __init__(self, db_file='leapp.db', context=None, user_version=None):
        super(LeappDatabase, self).__init__(db_file)
        self._context = context if context else self._last_execution_context()
        self._data = self._get_audit_logs()
        self._user_version = user_version

        db_user_version = self.get_user_version()
        if self._user_version is None:
            self._user_version = db_user_version

        if self._user_version > db_user_version:
            raise ValueError((
                f"Specified user version ({self._user_version}) is greater than"
                f" the user version of database ({db_user_version})."
            ))

    def get_user_version(self):
        """
        Get the value of PRAGMA user_version
        """
        cursor = self.execute("PRAGMA user_version;")
        user_version = cursor.fetchone()[0]
        return user_version

    def _user_version_satisfied(self, version):
        return self._user_version >= version

    def get_executions(self):
        cursor = self.execute("SELECT id,context,stamp FROM execution")
        return cursor.fetchall()

    def _last_execution_context(self):
        executions = self.get_executions()
        if not executions:
            raise LeappDatabaseEmpty("Leapp has not been executed yet.")
        return executions[-1]["context"]

    def _get_execute_cond(self, table=None):
        if table:
            return ["{}.context = '{}'".format(table, self._context)]
        return ["context = '{}'".format(self._context)]

    def _get_audit_logs(self):
        """
        Get audit logs from the audit table.
        """
        cond = self._get_execute_cond("audit")

        # NOTE: enable this condition if you want to get just data visible
        # on terminal...
        # cond.append("(audit.event != 'new-message' OR messages_data.topic == 'errors')")
        cols = ["audit.id", "audit.event", "audit.stamp",
                "audit.data_source_id", "audit.message_id",
                "data_source.actor", "data_source.phase", "audit.data",
                "messages_data.topic", "messages_data.type",
                "messages_data.message_data"]
        cmd = ("SELECT {cols} FROM audit"
               " LEFT JOIN data_source ON data_source_id = data_source.id"
               " LEFT JOIN messages_data ON audit.message_id = messages_data.id"
               " WHERE {cond}"
               .format(cond=' AND '.join(cond), cols=','.join(cols)))
        return self.execute(cmd).fetchall()

    def get_logs(self, phase=None, actor=None, log_level=LogLevels.DEBUG):
        """
        Get audit logs.

        By default, all logs are returned. But it could be filtered by
        specified phase, actor's name, or lower the log level (e.g. return just
        error logs).
        """
        level_map = {
            "ERROR": LogLevels.ERROR,
            "WARNING": LogLevels.WARNING,
            "INFO": LogLevels.INFO,
            "DEBUG": LogLevels.DEBUG
        }
        logs = self._filter_data(event="log-message", phase=phase, actor=actor)

        for log in logs:
            # the detection of log level is quite expensive operation because
            # of the required decode of JSON object. So in case the DEBUG level
            # just yield it.
            if log_level == LogLevels.DEBUG:
                yield log
                continue
            data = json.loads(log["data"])
            # if the level is unkown to the map, understand it as the error lvl
            if level_map.get(data["level"], LogLevels.ERROR) <= log_level:
                yield log

    def _filter_data(self, actor=None, phase=None, event=None):
        for row in self._data:
            if actor is not None and actor != row['actor']:
                continue
            if phase is not None and phase != row['phase']:
                continue
            if event is not None and event != row['event']:
                continue
            yield row

    def get_messages(self, msg_type=None, phase=None, actor=None):
        """
        Get messages produced by actors.

        Messages can be filtered to specified phase, actor, and message type
        (alias model of the message, e.g. IPUConfig).
        """
        msgs = self._filter_data(event="new-message", phase=phase, actor=actor)
        if msg_type:
            return [msg for msg in msgs if msg["type"] == msg_type]
        return list(msgs)

    def get_execution_length(self, execution=None):
        """
        Get information about length of execution.
        """
        raise NotImplementedError()

    def get_entities(self, kind):
        """
        Get a list of entities of the given kind for the selected execution.
        Currently entities are of kind: actor, metadata.
        """

        if not self._user_version_satisfied(3):
            return []

        cmd = ("SELECT name FROM entity"
               " WHERE kind = '{kind}' AND context = '{context}'"
               " ORDER BY id ASC"
               .format(kind=kind, context=self._context))
        results = self.execute(cmd).fetchall()

        return [row["name"] for row in results]

    def get_entity_metadata(self, kind, name):
        """
        Get metadata of the specified entity.
        """

        if not self._user_version_satisfied(3):
            return {}

        cmd = ("SELECT metadata.metadata FROM entity"
               " LEFT JOIN metadata ON metadata_hash = metadata.hash"
               " WHERE context = '{context}' AND kind = '{kind}' AND name = '{name}'"
               .format(context=self._context, kind=kind, name=name))
        result = self.execute(cmd).fetchone()

        if result:
            return json.loads(result["metadata"])

        return {}

    def get_workflows(self):
        """
        Return a discovered workflows.
        """

        if not self._user_version_satisfied(3):
            # TODO(dkubek): Can we get workflows somewhere else?
            return []

        return self.get_entities('workflow')

    def get_actors(self):
        """
        Return a set of discovered actors (in alphabetical order)
        """

        if not self._user_version_satisfied(3):
            return self.get_executed_actors()

        return self.get_entities('actor')

    def get_actor_exit_status(self, actor_name):
        """
        Return the exit status of the actor. Can be either:

            - 'success': success or handled failure
            - 'fail': unhandled failure
            - 'unexecuted': not specified (unexecuted)
            - 'unknown': not provided by the framework
        """

        if not self._user_version_satisfied(3):
            return 'unknown'

        event = next(self._filter_data(actor=actor_name, event="actor-exit-status"), None)
        if event is None:
            return 'unexecuted'

        data = json.loads(event["data"])

        exit_status = data.get("exit_status", None)

        if exit_status == 0:
            return 'success'

        if exit_status == 1:
            return 'fail'

        raise NotImplementedError('Handling for exit status {} is not implemented'.format(exit_status))

    def get_productive_actors(self):
        """
        Return a set of actors that produced a msg
        """
        return {msg["actor"] for msg in self.get_messages()}

    def get_models(self):
        """
        Return a set of models of produced msgs
        """
        return {msg["type"] for msg in self.get_messages()}

    def get_executed_phases(self):
        """
        Return phases of the workflow that have been executed (or reached)
        in the execution order.
        """
        phases = list()
        for log in self._filter_data(event="log-message"):
            if "Starting stage" in log["data"] and log["phase"] not in phases:
                phases.append(log["phase"])
        return phases

    def get_last_executed_phase(self):
        """
        Get the last phase that has been executed or None if no executed phase
        detected

        This doesn't mean that all actors in the phase has been executed. It
        is possible even that phase has been interrupted by an error before
        any actor could be be executed. It's just last phase, that has been
        started regarding the audit logs.
        """
        try:
            return self.get_executed_phases()[-1]
        except IndexError:
            return None

    def get_executed_actors(self, phase=None):
        """
        Get executed actors in the order of execution.

        Additionally, can be specified a phase which you are interested.
        :param str phase: if specified, return only actors executed in the phase;
        """
        actors_regexp = re.compile(r"Executing actor ([^\s]+)")
        actors = list()
        for log in self._filter_data(event="log-message"):
            match = actors_regexp.search(log["data"])
            if not match:
                continue
            if not phase or (phase and phase == log["phase"]):
                actors.append(match.group(1))
        return actors

    def get_last_executed_actor(self):
        """
        Get the last actor that has been executed or None if no executed actor
        detected
        """
        try:
            return self.get_executed_actors()[-1]
        except IndexError:
            return None

    def get_dialogs(self, scope=None):
        """
        Get information about dialogs for the current context.
        """

        if not self._user_version_satisfied(3):
            return []

        cond = ["context = '{}'".format(self._context)]
        if scope:
            cond.append("scope = '{}'".format(scope))

        results = self.execute(
            "SELECT scope, data FROM dialog WHERE {cond}"
            .format(cond=' AND '.join(cond))
        ).fetchall()

        dialogs = []
        for result in results:
            dialogs.append({
                "scope": result["scope"],
                "data": json.loads(result["data"])
            })

        return dialogs

    def get_status(self):
        """
        Return status of the execution

        The function should inform whether execution ended because of error,
        checkout, inhibition or everything done.

        It could be tricky because of the issue in the framework:
          https://github.com/oamg/leapp/issues/609
        As well, not sure whether we are able to tell the workflow execution
        is completely finished.
          TODO: investigate the messages in audit whether it is possible to
                detect it
        """
        raise NotImplementedError()

    def _get_cmd_results(self, phase=None, actor=None, failed_only=False):
        """
        Return an iterator over CMDs results.

        Can be filtered to return just failed results.
        """
        for cmd_res in self._filter_data(event="process-result", phase=phase, actor=actor):
            if failed_only:
                if int(json.loads(cmd_res["data"])["result"]["exit_code"]):
                    yield cmd_res
            else:
                yield cmd_res

    def get_errors(self, phase=None, actor=None, check_logs=True, check_cmd_exit=False):
        """
        Get all raised errors (advice: read the whole docstring first!)

        It's possible to filter errors for specific phase or actor. Currently
        we can detect several possible types of errors:
          a) an error reported as a message (ErrorModel) that is printed
             in the generated report; it's covers situation like unhandled
             crash of an actor or raised StopActorExecutionError
          b) a log with the ERROR level; logger().error("...")
          c) exit code of executed sub-shell command (via the run() function)

        By default the a) and b) errors are snanned. The c) errors could be
        false-positives as some subcommands are expected to return non-zero
        exit code (e.g. when author wants to obtain false/true information
        about something).

        IMPORTANT INFO: Data about errors are stored under various keys!! For:
          - a)      - see key: "messages_data"
          - b) & c) - see key: "data"

        Errors are sorted chronologically.
        """
        # FIXME: decide before the merge (fix or keep...) and remove the fixme
        # comment:
        # - Unify the output (doesn't matter whether error a), b), or c)) e.g.
        # * via defined class; (no difference in access to data..)
        # - Keep it as it is (it's not convenient, but....)
        # ... and it this function/method really good idea at all?

        errors = self.get_messages(msg_type="ErrorModel", phase=phase, actor=actor)

        if check_logs:
            for log in self.get_logs(phase=phase, actor=actor, log_level=LogLevels.ERROR):
                errors.append(log)

        if check_cmd_exit:
            for cmd_res in self._get_cmd_results(phase=phase, actor=actor, failed_only=True):
                errors.append(cmd_res)

        # sorting via id is chronologic and safer than string "stamp"
        return sorted(errors, key=lambda x: x["id"])

    def get_reports(self):
        """
        Get all report messages.
        """
        return self.get_messages(msg_type="Report")


class Color(object):
    reset = "\033[0m" if sys.stdout.isatty() else ""
    bold = "\033[1m" if sys.stdout.isatty() else ""
    red = "\033[1;31m" if sys.stdout.isatty() else ""
    green = "\033[1;32m" if sys.stdout.isatty() else ""
    yellow = "\033[1;33m" if sys.stdout.isatty() else ""
    blue = "\033[1;34m" if sys.stdout.isatty() else ""


class LeappDataPrinter(LeappDatabase):
    """
    Print various leapp data in suitable format for reading.

    Just extend the LeappDatabase class with readable printers.
    It can be used to simplify additional implementation
    of the "main-subcommand" functions.
    """

    FULL_SEP_CHAR = "#"
    SIMPLE_SEP_CHAR = "-"

    ACTOR_STATUS_INDICATOR_UNEXECUTED = "○"
    ACTOR_STATUS_INDICATOR_EXECUTED = "●"
    ACTOR_STATUS_INDICATOR_UNKNOWN = "(?)"

    def __init__(self, db_file='leapp.db', context=None, user_version=None):
        super(LeappDataPrinter, self).__init__(
            db_file=db_file, context=context, user_version=user_version
        )
        self._width = 70

    def _print_header(self, header_title):
        print("{sep}\n{title}\n{sep}".format(
            sep=self.FULL_SEP_CHAR*self._width,
            title=header_title.center(self._width)
        ))

    def _print_separator(self, full=False, msg=""):
        sep = self.FULL_SEP_CHAR if full else self.SIMPLE_SEP_CHAR
        if msg:
            msg = " {} ".format(msg)
        print(msg.center(self._width, sep))

    def _print_tail(self):
        self._print_separator(full=True)

    @staticmethod
    def _format(elem, fmt):
        """
        Format a given object `elem` using the specified format `fmt`.

        Parameters:
        elem : Any
            The object to be formatted.
        fmt : None, callable, dict, or list
            The format specification, which can be:
            - None: The `elem` is converted to a string using `str(elem)`.
            - Callable: A function `f` that returns `f(elem)`, which must be a
              string.
            - Dictionary: Uses `LeappDataPrinter.format_dict` for formatting.
            - List: Uses `LeappDataPrinter.format_list` for formatting.

        Returns:
        str
            The formatted string representation of `elem`.

        Raises:
        ValueError
            If the format specification is not implemented for `elem`.
        """

        if fmt is None:
            fmt = str

        if callable(fmt):
            return str(fmt(elem))

        if isinstance(elem, Mapping):
            return LeappDataPrinter.format_dict(elem, fmt)

        if isinstance(elem, Iterable):
            return LeappDataPrinter.format_list(elem, fmt)

        assert ValueError("Formatting {} with {} not implemented!".format(type(elem), fmt))

    @staticmethod
    def format_list(
            t,
            fmt=None,
            indent_char="  ", list_bullet="- ",
            list_start=None, list_continue=None, list_end=None,
            list_empty="---",
    ):
        """
        Format a given list into a structured string representation.

        Parameters:
        t : list
            The list to be formatted.
        fmt : None, callable, or list, optional
            - Callable: Applied to each element, returning a string representation.
            - List: Each element specifies a format for the corresponding element in `t`.

        indent_char : str, optional
            The character(s) used for indentation (default: "  ").
        list_bullet : str, optional
            The bullet used for list elements (default: "- ").
        list_start : str, optional
            The bullet for the first list element (default: `list_bullet`).
        list_continue : str, optional
            The bullet for continued items (default: `indent_char`).
        list_end : str, optional
            The bullet for the last list element (default: `list_bullet`).
        list_empty : str, optional
            The string to return if the list is empty (default: "---").

        Returns:
        str
            The formatted list as a string.

        Raises:
        ValueError
            If `fmt` is a list but its length does not match `t`.
        """

        list_start = list_start or list_bullet
        list_continue = list_continue or indent_char
        list_end = list_end or list_bullet

        if not t:
            return list_empty

        # Validate and normalize format specification
        if isinstance(fmt, list):
            if len(fmt) != len(t):
                msg = "The fmt is of type {} and size {} which does not match the input size {}!".format(
                    type(fmt), len(fmt), len(t))
                raise ValueError(msg)

            transform = iter(fmt)
        else:
            transform = itertools.repeat(fmt)

        lines = []
        for elem, tr in zip(t, transform):
            result = LeappDataPrinter._format(elem, tr).split('\n')

            lines.append([list_start, result[0]])
            for i in range(1, len(result)):
                lines.append([list_continue, result[i]])

        if lines:
            lines[-1][0] = list_end

        return '\n'.join(''.join(line) for line in lines)

    @staticmethod
    def format_dict(d, fmt=None, indent=4, indent_char=" ", empty_field="---", justify="ljust"):
        """
        Format a dictionary into a structured string representation.

        Parameters:
        d : dict
            The dictionary to be formatted.
        fmt : None, iterable of tuples, or callable, optional
            - Iterable of tuples: Each tuple is a format specification in the form:
                (fieldname, key, default, fmt, child)
              where:
                - fieldname (str): Display name of the field.
                - key (str): Key in the dictionary.
                - default: Default value if key is missing; None means field will be omitted.
                - fmt: Format specifier (see).
                - child (bool): Whether to indent this field as a child.
        indent : int, optional
            Number of spaces for indentation of child elements (default: 4).
        indent_char : str, optional
            Character(s) used for indentation (default: " ").
        empty_field : str, optional
            String returned if the dictionary is empty (default: "---").
        justify : str, optional
            Justification method for field names, either "rjust" or "ljust" (default: "ljust").

        Returns:
        str
            The formatted dictionary as a string.

        Raises:
        ValueError
            If any entry in `fmt` is an invalid format specification.
        """

        if not d:
            return empty_field

        if isinstance(fmt, Iterable):
            for entry_fmt in fmt:
                if isinstance(entry_fmt, tuple) and len(entry_fmt) != 5:
                    msg = "Entry {} is not a valid format specification".format(entry_fmt)
                    raise ValueError(msg)
        else:
            fmt = [(key, key, None, fmt, False) for key in d]

        fieldname_align_width = max(len(f[0]) for f in fmt)

        lines = []

        for fieldname, field, default, field_fmt, is_child in fmt:
            offset = indent if is_child else fieldname_align_width + 2

            value = d.get(field, default)
            if value is None:
                continue
            result = LeappDataPrinter._format(value, field_fmt).split('\n')

            fieldname = getattr(fieldname + ":", justify)(fieldname_align_width + 1)
            for i, line in enumerate(result):
                if i == 0:
                    if not is_child:
                        lines.append(["{} {}".format(fieldname, line)])
                        continue

                    lines.append(["{}".format(fieldname)])

                lines.append([indent_char * offset, line])

        return '\n'.join(''.join(line) for line in lines)

    @staticmethod
    def format_exit_status_indicator(exit_status):

        symbol = LeappDataPrinter.ACTOR_STATUS_INDICATOR_EXECUTED
        if exit_status == "unexecuted":
            symbol = LeappDataPrinter.ACTOR_STATUS_INDICATOR_UNEXECUTED
        elif exit_status == "unknown":
            symbol = LeappDataPrinter.ACTOR_STATUS_INDICATOR_UNKNOWN

        color = Color.reset
        if exit_status == "success":
            color = Color.green
        elif exit_status == "fail":
            color = Color.red
        elif exit_status == "unexecuted":
            color = Color.blue

        indicator = ""
        if sys.stdout.isatty():
            indicator = "{color}{symbol}{reset}".format(color=color, symbol=symbol, reset=Color.reset)

        return indicator

    @staticmethod
    def _fmt_msg_data(data, recursive=False, stack=0):
        try:
            json_data = json.loads(data)
        except JSONDecodeError:
            # ignore these errors; not everything is json. just return
            # the input argument
            return data
        except TypeError:
            if not stack:
                # on the top level (stack zero) the json is always expected for
                # message data
                raise
            return data

        # NOTE: the dict should be sufficient in most cases. I haven't realized
        # any message we need to hanle specifically e.g. list values for the
        # recursive processing. Add in case any example is discovered.
        if recursive and isinstance(json_data, dict):
            for key, val in json_data.items():
                json_data[key] = LeappDataPrinter._fmt_msg_data(
                    val, recursive, stack + 1
                )
        if stack > 0:
            return json_data
        return json.dumps(json_data, indent=4, sort_keys=True)

    @staticmethod
    def print_message(msg, recursive=False):
        for i in ("stamp", "actor", "phase", "type"):
            print("{}: {}".format(i.capitalize(), msg[i]))
        data = LeappDataPrinter._fmt_msg_data(msg["message_data"], recursive=recursive)
        print("Message_data:\n{}".format(data))

    def print_messages(self, actor=None, phase=None, msg_type=None, recursive=False):
        """
        TODO:
        """
        msgs = self.get_messages(actor=actor, phase=phase, msg_type=msg_type)
        self._print_header("PRODUCED MESSAGES")
        try:
            LeappDataPrinter.print_message(msgs.pop(), recursive)
            for msg in msgs:
                self._print_separator()
                LeappDataPrinter.print_message(msg, recursive)
        except IndexError:
            print()
        self._print_tail()

    def print_actor(
            self, actor_name,
            log_level=LogLevels.DEBUG,
            terminal_like_logs=True,
            show_description=False,
            show_config=False
    ):
        """
        Print information about the specified actor.

        It's possible to set the level of logs that should be printed as some
        actors could provide big amount of logs that could reduce readability
        of the output.

        Printed logs usually contains metadata. It's possible to hide metadata
        and print the pure data only (like printed in terminal during the leapp
        execution).
        """

        def get_metadata(actor_name):
            metadata = self.get_entity_metadata('actor', actor_name)

            actors_regexp = re.compile(r"Executing actor ([^\s]+)")
            for log in self._filter_data(event="log-message"):
                match = actors_regexp.search(log["data"])
                if match and match.group(1) == actor_name:
                    metadata["stamp"] = log["stamp"]
                    metadata["phase"] = metadata.get("phase", None) or log["phase"]
                    break

            return metadata

        actor = get_metadata(actor_name)
        if actor is None:
            print("Actor {} not found!".format(actor_name), file=sys.stderr)
            return

        actor["name"] = actor.get("name", None) or actor_name
        actor["exit_status"] = self.get_actor_exit_status(actor_name)
        actor["msgs"] = [msg["type"] for msg in self.get_messages(actor=actor_name)]

        indicator = LeappDataPrinter.format_exit_status_indicator(actor['exit_status'])
        print("{indicator} {actor_name}".format(indicator=indicator, actor_name=actor_name))

        list_style = {
            "indent_char": " ", "list_bullet": "── ",
            "list_start": "├─ ", "list_continue": "│  ", "list_end": "└─ ",
            "list_empty": "---"}

        def pretty_list(t):
            return LeappDataPrinter.format_list(t, **list_style)

        def lstrip_lines(s):
            return '\n'.join(line.lstrip() for line in s.split('\n'))

        def recursive_format_dict(field):
            if not isinstance(field, dict):
                if isinstance(field, str):
                    return lstrip_lines(field)
                return field

            ans = {}
            for key in field:
                ans[key] = recursive_format_dict(field[key])

            return LeappDataPrinter.format_dict(ans)

        def format_config(config):
            config_fmt = [
                ("Class", "class_name", "", None, False),
                ("Section", "section", "", None, False),
                ("Name", "name", "", None, False),
                ("Description", "description", "", lstrip_lines, True),
                ("Type", "type", "", recursive_format_dict, False),
                ("Default", "default", "", None, False),
            ]

            return LeappDataPrinter.format_dict(config, fmt=config_fmt)

        def format_config(config):
            return recursive_format_dict(config)

        def format_config_schemas(t):
            if show_config:
                return LeappDataPrinter.format_list(t, fmt=format_config, **list_style)

            return "[OPTIMIZED OUT]"

        def format_description(description):
            if show_description:
                return lstrip_lines(description)

            return "[OPTIMIZED OUT]"

        actor_fmt = [
            ("Actor", "name", None, None, False),
            ("Class", "class_name", None, None, False),
            ("Description", "description", None, format_description, show_description),
            ("Path", "path", None, None, False),
            ("Exit Status", "exit_status", None, None, False),
            ("Executed", "stamp", None, lambda _: _ is not None, False),
            ("Started", "stamp", None, lambda _: _ or "---", False),
            ("Phase", "phase", "", None, False),
            ("Tags", "tags", None, pretty_list, True),
            ("Config Schemas", "config_schemas", None, format_config_schemas, show_config),
            ("Config", "config", None, format_config, True),
            ("Consumes", "consumes", None, pretty_list, True),
            ("Produces", "produces", None, pretty_list, True),
            ("Produced", "msgs", None, pretty_list, True),
        ]
        print(LeappDataPrinter.format_dict(actor, actor_fmt))
        print()

        dialogs = self.get_dialogs(actor_name)

        def component_fmt(comp):
            fmt = [
                ("Label", "label", "", None, False),
                ("Description", "description", "", None, False),
                ("Reason", "reason", "", None, False),
                ("Key", "key", "", None, False),
                ("Value", "value", "", None, False),
            ]
            return LeappDataPrinter.format_dict(comp, fmt=fmt)

        def dialog_fmt(dialog):
            fmt = [
                ("Title", "title", "", None, False),
                ("Reason", "reason", "", None, False),
                ("Components", "components", [], lambda _: LeappDataPrinter.format_list(
                    _, fmt=component_fmt, **list_style), True),
            ]
            return LeappDataPrinter.format_dict(dialog["data"], fmt=fmt)

        if dialogs:
            print("Dialogs:")
            print(LeappDataPrinter.format_list(dialogs, fmt=dialog_fmt, **list_style))
            print()

        # NOTE(pstodulk): That regular is terrible, I know
        # be aware that order of json fields in the log is different on
        # py2 and py3
        cmd_regexp = re.compile(r"External command has started: (.+\])\"[,}]")
        cmds = []
        for log in self.get_logs(actor=actor_name):
            match = cmd_regexp.search(log["data"])
            if match:
                cmds.append(match.group(1))

        if cmds:
            print("Executed shell commands:")
            print(LeappDataPrinter.format_list(cmds))
            print()

        logs = self.get_logs(actor=actor_name, log_level=log_level)
        for i, log in enumerate(logs):
            if i == 0:
                print("Logs:")

            if terminal_like_logs:
                print("    {}".format(json.loads(log["data"])["message"]))
            else:
                print("--- {}".format(log["data"]))

    def print_actors(self, **kwargs):
        """
        Print various information about actors
        """

        actors = self.get_actors()
        self._print_header("DISCOVERED ACTORS")
        try:
            self.print_actor(actors.pop(0), **kwargs)
            for actor_name in actors:
                self._print_separator()
                self.print_actor(actor_name, **kwargs)
        except IndexError:
            print()
        self._print_tail()

    def print_workflow(self, workflow_name, short=False):
        """
        Print information about the specified workflow.
        """

        workflow = self.get_entity_metadata('workflow', workflow_name)
        if workflow is None:
            print("Workflow {} not found!".format(workflow_name), file=sys.stderr)
            return

        workflow['phases'] = sorted(
            workflow.get("phases", []),
            key=lambda phase: phase["index"]
        )

        list_style = {
            "indent_char": "  ", "list_bullet": "● ",
            "list_start": "│\n●  ", "list_continue": "│  ", "list_end": "└  ",
            "list_empty": "---"}

        def phase_fmt_long(phase):
            fmt = [
                ("Name", "name", "", None, False),
                ("Class name", "class_name", "", None, False),
                ("Index", "index", "", None, False),
                ("Policies", "policies", [], LeappDataPrinter.format_dict, True),
                ("Flags", "flags", [], LeappDataPrinter.format_dict, True),
                ("Filter", "filter", [], LeappDataPrinter.format_dict, True),
            ]
            return LeappDataPrinter.format_dict(phase, fmt=fmt)

        def phase_fmt_short(phase):
            return phase.get("name", "")

        phase_fmt = phase_fmt_short if short else phase_fmt_long
        list_style = {} if short else list_style

        workflow_fmt = [
            ("Name", "name", "", None, False),
            ("Short Name", "short_name", "", None, False),
            ("Tag", "tag", "", None, False),
            ("Description", "description", "", None, False),
            ("Phases", "phases", [], lambda _: LeappDataPrinter.format_list(_, fmt=phase_fmt, **list_style), True)
        ]
        print(LeappDataPrinter.format_dict(workflow, fmt=workflow_fmt))

    def print_workflows(self, short=False):
        """
        Print various information about workflows.
        """
        workflows = self.get_workflows()
        self._print_header("DISCOVERED WORKFLOWS")
        try:
            self.print_workflow(workflows.pop(0), short=short)
            for workflow_name in workflows:
                self._print_separator()
                self.print_workflow(workflow_name)
        except IndexError:
            print()
        self._print_tail()

    def print_execution_info(self, execution):
        """Print info about defined execution."""
        # TODO: add info about used envars as well from the IPUConfig msg
        # - to make it more robust, check whether such message exists, if not,
        # do not crash, just skip it or report the missing data...
        raise NotImplementedError()

    def print_terminal_output(self):
        """
        Reconstruct the output on terminal.

        The output doesn't have to be completely same, as order can be
        sometimes changed - in the meaning that stderr and stdout of procesed
        commands is printed in runtime and can be mixed, but in db they are
        separated. There could be additional discrepancies - like missing
        errors printed out of leapp completely.
        """
        # NOTE: Q: enable switch with/without debug, only stderr, only stdout,
        # or even output related just to specific phase or actor?
        # - does it make sense to provide anything from that?....
        # - keep it stupid now, until all usecases are written and cmdline
        #   designed
        raise NotImplementedError()

# #################################
# Stuff related to the tool and CLI
# #################################


class SubCommandBaseClass():
    """
    This is base class for CLI subcommands of Leapp Inspector

    To add new subcommand for the Leapp Inspector tool, just derive new class
    and implement methods below. For registration of the subcommand use an
    instance of LeappInspectorCLI class and call the add_subcommand method
    giving the derived class as an input parameter. e.g.:
        li_cli = LeappInspectorCLI()
        li_cli.add_subcommand(<SubCommandClass>)
    """

    name = None
    """
    Set the subcommand name in the derived subclasses.

    The string is the one expected to use on the commandline to execute
    specific subcommand. E.g. if name = "mycmd", then on  cmdline:
        leapp-inspector mycmd
    does the thing.
    """

    help_short_str = None
    """
    The short help message message summarizing the sub-command purpose.

    It's the message you see next to your subcommand when call
        leapp-inspector --help
    """

    def __init__(self, leapp_inspector_cli):
        if type(self) is SubCommandBaseClass:
            raise Exception("The base class cannot be instantiated directly.")
        if not isinstance(leapp_inspector_cli, LeappInspectorCLI):
            raise ValueError("leapp_inspector_cli must be instance of LeappInspectorCLI")
        self.li_cli = leapp_inspector_cli
        self._register_cmd()

    @property
    def cmd_name(self):
        if not self.name or not isinstance(self.name, str):
            raise ValueError(
                "The <class>.name string must be specified in derived classes."
                " E.g. 'messages'."
            )
        return self.name

    @property
    def help_short(self):
        if not self.help_short_str or not isinstance(self.help_short_str, str):
            raise ValueError(
                "The <class>.help_short_str string must be specified in"
                " derived classes."
            )
        return self.help_short_str

    def set_arguments(self):
        raise NotImplementedError("Must be implemented in derived class.")

    def process(self):
        raise NotImplementedError("Must be implemented in derived class.")

    def _register_cmd(self):
        self.subparser = self.li_cli.add_parser(
            self.cmd_name,
            help=self.help_short,
        )
        self.set_arguments()

    @property
    def LeappDatabase(self):
        return self.li_cli.LeappDatabase

    @property
    def LeappDataPrinter(self):
        return self.li_cli.LeappDataPrinter

    @property
    def cmdline(self):
        return self.li_cli.cmdline


class LeappInspectorCLI:
    """
    The main class of Leapp Inspector for CLI

    Adjustable parsing of the CLI based on registered sub-commands.
    """

    DEFAULT_DB_PATHS = ["leapp.db", "/var/lib/leapp/leapp.db"]
    LEAPP_CONFIG_FILE = "/etc/leapp/leapp.conf"

    def __init__(self):
        # TODO: replace _cmd_func_map by parser.set_default(...)
        self._parser = argparse.ArgumentParser(prog="Leapp Inspector")
        self._cmd_func_map = {}
        self._add_top_lvl_options()
        self._subparsers = self._parser.add_subparsers(
            title="Subcommands",
            help="subcommands help",
            dest="subcmd",
        )
        self.cmdline = None

        # internally stored instances of LeappDatabase and LeappDataPrinter
        self._ld = None
        self._ldp = None

    def print_help(self):
        self._parser.print_help()

    def add_parser(self, name, **kwargs):
        """
        Return subparser that can be used and adjusted by subcommands.
        """
        return self._subparsers.add_parser(name, **kwargs)

    def add_subcommand(self, subcmd_class):
        """
        Add/register new subcommand for the Leapp Inspector tool

        Expected class derived from SubCommandBaseClass.
        """
        subcmd = subcmd_class(self)
        self._cmd_func_map[subcmd.cmd_name] = subcmd.process

    def parse(self):
        """
        Parse cmdline input
        """
        self.cmdline = self._parser.parse_args()

    def process(self):
        """
        Execute the process method of the chosen subcommand.

        It's the process method of the subcommand registered by add_subcommand()
        """
        if not self.cmdline:
            raise ValueError("Missing parsed CLI. Run self.parse() first.")
        if self.cmdline.subcmd:
            self._cmd_func_map[self.cmdline.subcmd]()
        else:
            # no subcommand specified -> print help
            self._cmd_func_map["help"]()

    @property
    def LeappDatabase(self):
        if not self.cmdline:
            raise ValueError("Missing parsed CLI. Run self.parse() first.")
        if self._ld:
            return self._ld
        self._ld = LeappDatabase(
            db_file=self.cmdline.db_file,
            context=self.cmdline.context,
            user_version=self.cmdline.user_version,
        )
        return self._ld

    @property
    def LeappDataPrinter(self):
        if not self.cmdline:
            raise ValueError("Missing parsed CLI. Run self.parse() first.")
        if self._ldp:
            return self._ldp
        self._ldp = LeappDataPrinter(
            db_file=self.cmdline.db_file,
            context=self.cmdline.context,
            user_version=self.cmdline.user_version,
        )
        return self._ldp

    def _add_top_lvl_options(self):
        self._parser.add_argument(
            "--db", metavar="FILE", dest="db_file", default=self._default_path(),
            help=(
                "Specify the path to the leapp.db file. By default"
                " looks for leapp.db file in the current (PWD) directory,"
                " /var/lib/leapp/leapp.db, and path specified by the leapp"
                " configuration file if present (in this order).")
        )
        self._parser.add_argument(
            "--context", metavar="CONTEXT", dest="context", default=None,
            help=(
                "Specify the CONTEXT (execution of leapp) that should be"
                " loaded and processed. By default the last leapp session"
                " is processed when not specified. So see possible contexts"
                " you can use e.g. `leapp-inspector contexts` cmd. Example"
                " of context: '2548112d-3d20-49ca-908f-2b4b6b3bdb84'")
        )
        self._parser.add_argument(
            "--user-version", metavar="USER_VERSION", dest="user_version", type=int, default=None,
            help=(
                "Specify the USER_VERSION (the PRAGMA of the leapp database)"
                " that should be used to determine the format and availability"
                " of information in the leapp database. By defaul, USER_VERSION"
                " is the latest version set in the database."
            )
        )

    def _default_path(self):
        """
        Return the first existing leapp db file from DEFAULT_DB_PATHS or
        "leapp.db".

        People have usually two types of expectations:
          - work with the leapp.db file in the PWD
          - work with the leapp.db file on the default path
            (typically /var/lib/leapp/leapp.db)

        To cover both usecases, let's provide the list of paths which should
        be checked by default and the first existing path is returned.

        Be aware that the path of the leapp.db file created by leapp could
        be changed inside the leapp configuration file. The function reflects
        it, but after the default paths are checked! This is valid only in
        cases Leapp Inspector is run on a machine with installed Leapp.

        In case leapp.db file is not found on any specified default path,
        return just "leapp.db".
        """
        for db_file in self.DEFAULT_DB_PATHS:
            if os.path.exists(db_file):
                return db_file

        if os.path.exists(self.LEAPP_CONFIG_FILE):
            cp = ConfigParser()
            cp.read(self.LEAPP_CONFIG_FILE)
            db_file = cp.get(section="database", option="path")
            if os.path.exists(db_file):
                return db_file

        return "leapp.db"

# ###########
# Subcommands
# ###########


class HelpCLI(SubCommandBaseClass):

    name = "help"
    help_short_str = "Print this help"

    def set_arguments(self):
        pass

    def process(self):
        self.li_cli.print_help()


class WorkflowsCLI(SubCommandBaseClass):
    """
    The workflow subcommand for actions with workflows.
    """

    name = "workflows"
    help_short_str = "Print information about workflows"

    def set_arguments(self):
        self.subparser.add_argument("--list", dest="list", action="store_true",
                                    help="List all discovered workflows.")
        self.subparser.add_argument("--workflow", dest="workflow", default=None,
                                    help="Print information about selected workflow.")
        self.subparser.add_argument("--short", dest="short", action="store_true",
                                    help="Print only names of phases.")

    def process(self):
        cmdline = self.li_cli.cmdline

        if cmdline.list:
            for workflow in sorted(self.LeappDatabase.get_workflows()):
                print("    {}".format(workflow))
            return

        if cmdline.workflow:
            self.LeappDataPrinter.print_workflow(cmdline.workflow, short=cmdline.short)
            return

        self.LeappDataPrinter.print_workflows(short=cmdline.short)


class MessagesCLI(SubCommandBaseClass):
    """
    The message subcommand for actions with messages
    """

    name = "messages"
    help_short_str = "Print produced messages"

    def set_arguments(self):
        self.subparser.add_argument("--list", dest="msgs", action="store_true",
                                    help="List types of all produced messages.")
        self.subparser.add_argument("--actor", dest="actor", default=None,
                                    help="Print only messages produced by the actor.")
        self.subparser.add_argument("--type", dest="msg_type", default=None,
                                    help="Print only messages ot the specified type.")
        self.subparser.add_argument("--phase", dest="phase", default=None,
                                    help="Print only messages produced during the specified phase.")
        self.subparser.add_argument("--recursive-expand", dest="recursive", action="store_true",
                                    help=(
                                        "Expand all JSON data recursively. IOW, any json encoded"
                                        " as a string is decoded. Try it with the Report type to see"
                                        " the difference."
                                    ))

    def process(self):
        cmdline = self.li_cli.cmdline
        if cmdline.msgs:
            for actor in sorted(self.LeappDatabase.get_models()):
                print("    {}".format(actor))
            return
        self.LeappDataPrinter.print_messages(
            actor=cmdline.actor,
            phase=cmdline.phase,
            msg_type=cmdline.msg_type,
            recursive=cmdline.recursive,
        )


class ActorsCLI(SubCommandBaseClass):
    """
    The actor subcommand for actions with actors
    """

    name = "actors"
    help_short_str = "Print various information about actors"

    _log_level_map = {
        "ERROR": LogLevels.ERROR,
        "WARNING": LogLevels.WARNING,
        "INFO": LogLevels.INFO,
        "DEBUG": LogLevels.DEBUG
    }

    def set_arguments(self):
        group = self.subparser.add_argument_group('List options').add_mutually_exclusive_group()
        # TODO: currently we can obtain only dirnames of actors, not names of actors,
        # - which means we cannot effectively use this information right now.
        # - propose change in leapp to be able to get name of every discovered actor
        group.add_argument("--list", dest="list", action="store_const", const=ActorSelector.ANY,
                           help="List all discovered actors")
        group.add_argument("--list-executed", dest="list", action="store_const", const=ActorSelector.EXECUTED,
                           help="List all executed actors")
        group.add_argument("--list-producers", dest="list", action="store_const", const=ActorSelector.PRODUCER,
                           help="List all actors that produced any messages")
        group.add_argument("--actor", dest="actor", default=None,
                           help="Print data related just to the specified actor.")
        self.subparser.add_argument(
            "--log-level", dest="log_level", default="DEBUG",
            choices=self._log_level_map.keys(),
            help=(
                "Print logs of the given level and lower. The DEBUG level"
                " is the highest one and set by default. The ERROR level"
                " is the lowest."
            ))
        self.subparser.add_argument(
            "--terminal-like", dest="terminal_like", action="store_true",
            help=(
                "Logs are usually stored with additional metadata. Using this"
                " option, logs are printed like they are printed in terminal"
                " when leapp is executed - just indentation is added, for"
                " better readability, on the beginning of every log."
            ))
        self.subparser.add_argument(
            "--show-description", dest="show_description", action="store_true",
            help=(
                "For enhanced readability, description is hidden by default."
                " Enable this flag to show the actor description."
            ))
        self.subparser.add_argument(
            "--show-config", dest="show_config", action="store_true",
            help=(
                "For enhanced readability, config schema is hidden by default."
                " Enable this flag to show the actor config schema."
            ))

    def process(self):
        cmdline = self.li_cli.cmdline
        actors_dict = {
            ActorSelector.ANY: self.LeappDataPrinter.get_actors,
            ActorSelector.EXECUTED: self.LeappDataPrinter.get_executed_actors,
            ActorSelector.PRODUCER: self.LeappDataPrinter.get_productive_actors,
        }

        if cmdline.list:
            actors = actors_dict[cmdline.list]()
            # NOTE(dkubek): uncomment if want to print in alphabetical order
            # actors = sorted(actors)
            for actor in actors:
                exit_status = self.LeappDatabase.get_actor_exit_status(actor)

                indicator = LeappDataPrinter.format_exit_status_indicator(exit_status)
                print("{} {}".format(indicator, actor))
            return

        if cmdline.actor:
            self.LeappDataPrinter.print_actor(
                cmdline.actor,
                log_level=self._log_level_map[cmdline.log_level],
                terminal_like_logs=cmdline.terminal_like,
                show_description=cmdline.show_description,
                show_config=cmdline.show_config,
            )
            return

        self.LeappDataPrinter.print_actors(
            log_level=self._log_level_map[cmdline.log_level],
            terminal_like_logs=cmdline.terminal_like,
            show_description=cmdline.show_description,
            show_config=cmdline.show_config,
        )


class ExecutionsCLI(SubCommandBaseClass):

    name = "executions"
    help_short_str = "Print discovered executions of leapp on the machine"

    def set_arguments(self):
        pass

    def process(self):
        cmdline = self.li_cli.cmdline
        line_fmt = "{:36} | {:27}"
        self.LeappDataPrinter._print_header("Executions of Leapp")
        print(line_fmt.format("Execution", "Timestamp"))
        print(line_fmt.format("-"*36, "-"*27))
        for row in self.LeappDataPrinter.get_executions():
            print(line_fmt.format(row["context"], row["stamp"]))


class InteractiveCLI(SubCommandBaseClass):
    """
    The interactive subcommand to switch into the interactive Python mode.
    """

    name = "interactive"
    help_short_str = "Switch to interactive Python mode for manual experimenting"

    def set_arguments(self):
        pass

    def process(self):
        self.LeappDataPrinter._print_header("Switching to interactive mode")
        print(
            "This functionality is supposed to be used just by people\n"
            "that are familiar with the leapp-inspector source code."
        )
        print(
            "Hint:\n"
            "    Execute self.LeappDatabase or self.LeappDataPrinter to get\n"
            "    already initialized objects."
        )
        self.LeappDataPrinter._print_tail()
        import code
        _all_defs = globals().copy()
        _all_defs.update(locals())
        code.interact(local=_all_defs)


class InspectionCLI(SubCommandBaseClass):
    """
    The inspection subcommand for fast (high-level) inspection of the leapp
    execution.
    """

    name = "inspection"
    help_short_str = "Print high lvl report about run of leapp [EXPERIMENTAL]"

    def set_arguments(self):
        self.subparser.add_argument("--paranoid", dest="is_paranoid", action="store_true",
                                    help=(
                                        "Set inspection to the paranoid mode. Print possible errors"
                                        " when any sub command executed by actor return non-zero exit"
                                        " code. This can produce a lot of 'false positive' messages"
                                        " as many such failed subcommands are expected to be valid"
                                        " output. E.g. when detecting whether something is set, is"
                                        " expected the subcommand could return non-zero exit code."
                                        " That's why the mode is called paranoid. But sometimes could"
                                        " point on hidden issue.")
                                    )

    def process(self):
        ldp = self.LeappDataPrinter
        ldp._print_header("Inspection - summary data")
        print("Number of leapp executions: {}".format(len(ldp.get_executions())))
        print("Used Workflow: {}".format("(tbd)"))
        print("Leapp execution command: {}".format("(tbd)"))
        print("Used unsupported options? (tbd)")
        print("Used Leapp envars: (tbd)")
        print("Last executed phase: {}".format(ldp.get_last_executed_phase()))
        print("Last executed actor: {}".format(ldp.get_last_executed_actor()))
        print("Has been reported an error? {}".format(self._error_exists()))
        print("Has been reported an inhibitor? {}".format(self._inhibitor_exist()))
        ldp._print_header("Inspection - execution")
        for is_phase, phase_type, name in self._iter_phases_and_actors():
            if is_phase:
                print("==> {}  ({})".format(name, phase_type))
            else:
                print("====> {}".format(name))
            errors = ldp.get_errors(actor=name, check_logs=True, check_cmd_exit=self.cmdline.is_paranoid)
            if not errors:
                continue
            ldp._print_separator(msg="(Possible) Errors")
            for err in errors:
                if err["data"]:
                    print("--- {}".format(err["data"]))
                else:
                    ldp._print_separator()
                    # TODO: work on pretty printer of errors
                    LeappDataPrinter.print_message(err, True)
            ldp._print_separator()

    def _error_exists(self):
        # Ok, currently this returns just errors that have been reported (ErrorModel)
        # IOW, only fatal errors. Not errors logged used the logger.
        if self.LeappDatabase.get_errors(check_logs=False, check_cmd_exit=False):
            return True
        return False

    def _inhibitor_exist(self):
        for msg in self.LeappDatabase.get_messages(msg_type="Report"):
            data = json.loads(json.loads(msg["message_data"])["report"])
            # FIXME: flags are going to be removed and replace
            # by groups
            # FIXME: when the failure is used?
            # TODO: verify it works on leapp.db with inhibitor
            if "inhibitor" in data.get("flags", []):
                return True
        return False

    def _iter_phases_and_actors(self):
        actors_regexp = re.compile(r"Executing actor ([^\s]+)")
        phase_regexp = re.compile(r"Starting stage (Before|Main|After)")
        for log in self.LeappDatabase.get_logs():
            match = phase_regexp.search(log["data"])
            if match:
                yield True, match.group(1), log["phase"]
                continue
            match = actors_regexp.search(log["data"])
            if match:
                yield False, None, match.group(1)


# ###################################
# Some stuff related to main function
# ###################################

def set_default_subcommands(cli):
    cli.add_subcommand(HelpCLI)
    cli.add_subcommand(WorkflowsCLI)
    cli.add_subcommand(ActorsCLI)
    cli.add_subcommand(MessagesCLI)
    cli.add_subcommand(ExecutionsCLI)
    cli.add_subcommand(InteractiveCLI)
    cli.add_subcommand(InspectionCLI)


if __name__ == '__main__':
    try:
        cli = LeappInspectorCLI()
        set_default_subcommands(cli)
        cli.parse()
        cli.process()
    except socket.error as e:
        if e.errno != errno.EPIPE:
            raise
        devnull = os.open(os.devnull, os.O_WRONLY)
        os.dup2(devnull, sys.stdout.fileno())
